package com.example.demo.service;
import java.util.Date;

import java.util.HashMap;
import java.util.Optional;
import java.util.List;
import java.util.Map;
import java.util.Random;
import lombok.RequiredArgsConstructor;
import java.io.UnsupportedEncodingException;
import java.time.LocalDate;
import java.util.Date;
import java.util.Properties;
import jakarta.mail.Authenticator;
import jakarta.mail.Message;
import jakarta.mail.MessagingException;
import jakarta.mail.PasswordAuthentication;
import jakarta.mail.Session;
import jakarta.mail.Transport;
import jakarta.mail.internet.InternetAddress;
import jakarta.mail.internet.MimeMessage;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
//import org.springframework.http.ResponseEntity;
import com.example.demo.model.requestSoftware;
import com.example.demo.repository.requestRepository;
@Service
public class requestService {
	@Autowired
	requestRepository requestrepository;
	//create 	public requestSoftware createrequestSoftware(requestSoftware requestSoftware) {
      boolean exists = requestrepository.existsByUsernameAndId(requestSoftware.getUsername(), requestSoftware.getId());
        if (!exists) {
            // If no matching record exists, save the new record
            return requestrepository.save(requestSoftware);
        }
        
        // Handle the case where a duplicate record is not saved (e.g., throw an exception)
        return null;
        }

	//update
	public requestSoftware updateRequestSoftware(requestSoftware requestSoftware) {
	    // Check if the record with the given requestid exists in the database
	    Optional<requestSoftware> existingRequestSoftware = requestrepository.findById(requestSoftware.getRequestid());

	    if (existingRequestSoftware.isPresent()) {
	        // Update the existing record with the new values
	        requestSoftware updatedRequestSoftware = existingRequestSoftware.get();
	        updatedRequestSoftware.setSystemDate(requestSoftware.getSystemDate());
	        updatedRequestSoftware.setExpiryDate(requestSoftware.getExpiryDate());
	        updatedRequestSoftware.setStatus(requestSoftware.isStatus());
	        // Save the updated record to the database
	        return requestrepository.save(updatedRequestSoftware);
	    } 
	    else {
	        // Handle the case where the record with the given requestid is not found
	        return null;
	    }
	}
	public requestSoftware renewUserLicense(requestSoftware requestSoftware)
	{
        requestSoftware existingRequestSoftware = requestrepository.findByIdAndUsername(
                requestSoftware.getId(), requestSoftware.getUsername()
        );

        if (existingRequestSoftware != null) {
        	System.out.println("hii update softwareservice");
            LocalDate installationDate = LocalDate.now();
            System.out.println(installationDate);
            int validity = existingRequestSoftware.getValidity();
            System.out.println(validity);
            LocalDate newExpiryDate = installationDate.plusDays(validity);
            System.out.println(newExpiryDate);
            existingRequestSoftware.setSystemDate(installationDate);
            existingRequestSoftware.setExpiryDate(newExpiryDate);
            return requestrepository.save(existingRequestSoftware);
        } else {
            return null;
        }
    }
	public boolean deleteUserLicense(Long id, String username) {
        Optional<requestSoftware> userRecord = Optional.ofNullable(requestrepository.findByIdAndUsername(id, username));

        if (userRecord.isPresent()) {
            // Delete the user's record
        	requestrepository.deleteById(userRecord.get().getRequestid());
            return true;
        } else {
            return false;
        }
    }
	public List<requestSoftware> getActivatedrequestSoftware(){
		return requestrepository.findActivatedUser();
	}
	public List<requestSoftware> getRequestSoftwareByUser(String username) {
        return requestrepository.findByUsername(username);
    }
	public List<requestSoftware> getAllrequestSoftware() {
		return requestrepository.findAll();
	}
	public boolean sendLicenseKey(String email, String licenseKey) {
		System.out.println("Outlook Email Start");
		
		String smtpHostServer = "smtp.office365.com";
		final String emailID = "prosync80329@outlook.com";
		final String password = "Jerish@2002";
		String toEmail = email;
		String subject = "Autogenerated License Key";
		
		String messageBody = "Hello,\n\nYour license request has been accepted. Your autogenerated license key is: " + licenseKey + "\n\nPlease keep this key safe for future reference.Kindly install it by today\n\nBest regards,\nLicense Enginee admin";

		Properties props = new Properties();
		props.put("mail.smtp.host", smtpHostServer);
		props.put("mail.smtp.port", "587");
		props.put("mail.smtp.auth", "true");
		props.put("mail.smtp.starttls.enable", "true");

		Session session = Session.getInstance(props, new Authenticator() {
			
		protected PasswordAuthentication getPasswordAuthentication() {
			System.out.println(toEmail+"this is from to email");
			return new PasswordAuthentication(emailID, password);
		}
		});
		sendGeneratedLicenseKey(licenseKey,session, emailID, subject, messageBody, toEmail);
		return true;
		}
	public void sendGeneratedLicenseKey(String licenseKey, Session session, String emailID, String subject,
			String messageBody, String toEmail) {
				try {
					System.out.println(licenseKey);
					MimeMessage msg = new MimeMessage(session);
					msg.addHeader("Content-type", "text/HTML; charset=UTF-8");
					msg.addHeader("format", "flowed");
					msg.addHeader("Content-Transfer-Encoding", "8bit");
					msg.setFrom(new InternetAddress(emailID,"NoReply"));
					msg.setReplyTo(InternetAddress.parse(toEmail,false));
					msg.setRecipients(Message.RecipientType.TO,InternetAddress.parse(toEmail,false));
					msg.setSubject(subject, "UTF-8");
					msg.setSentDate(new Date());
					msg.setText(messageBody, "UTF-8");
					System.out.println("Message is ready");
					Transport.send(msg);
					System.out.println("Email Sent Successfully!!");
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
	public String generateLicenseKey() {
		Random random = new Random();
        int licenseKey = 100000 + random.nextInt(900000); // Generates a number between 100000 and 999999
        return String.valueOf(licenseKey);
			}

	//expirydate
	public  List<requestSoftware> getCustomersWithDueDate(LocalDate dueDateThreshold) {
		System.out.println("service class");
		return requestrepository.findByExpiryDate(dueDateThreshold);
	}
	
   //graph
	public Map<String, Long> getSoftwareCount() {
		// this list has objects of software with count
				List<Object[]> softwareCount = requestrepository.softwareCount();
						// map to have plan as key and count as value
						Map<String , Long> softwareCounts = new HashMap<>();
						for(Object[] object : softwareCount)
						{
							String software = (String) object[0];
							Long count = (Long) object[1];
							softwareCounts.put(software, count);
						}
						return softwareCounts;
				
	}
   //cardcount	
	public int getActivatedUserCount() {
		return requestrepository.findActivatedUserCount();
	}

	public int getUnActivatedUserCount() {
		return requestrepository.findUnActivatedUserCount();
	}
}
